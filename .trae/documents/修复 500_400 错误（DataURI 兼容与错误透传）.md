## 问题与证据
- 后端日志返回 `code/status: 50430`，文案为“Request Has Reached API Concurrent Limit, Please Try Later”，即梦侧并发上限触发。
- 前端出现 429/504：429 来自后端主动返回；504 来自后端 60 秒超时（未得到可用结果）。
- 提交阶段最易触发并发限制，需在后端做排队与退避重试。

## 方案（仅改后端）
- 在 `server/index.js` 为提交调用增加并发控制与指数退避重试：
  - 并发控制（信号量）：`MAX_CONCURRENT_SUBMIT = 1`，同时仅允许一个提交进行，其他请求等待（保持连接）。
  - 提交重试：捕获 `e.response.data.code === 50430` 或 429/503 类错误，进行指数退避（如 1.5s → 3s → 6s → 12s），总时长受整体 60s 超时约束。
  - 轮询保持原样；若提交阶段耗时较长，自动缩短轮询时间窗以不超过总超时。
- 错误透传日志：保留当前打印，同时在 429/50430 时打印重试次数与下一次等待时长。

## 改动点
- `server/index.js`
  - 新增全局并发计数与等待队列（或简化为 Promise 等待）：当正在提交时，后续请求排队。
  - 将 `signAndPost('CVSync2AsyncSubmitTask', ...)` 包装为 `submitWithRetry()`，内部处理 50430/429/503。
  - 总体超时仍为 60s，若超过则返回 504（带可读中文文案）。

## 验证
- 本地启动后端与前端，连续点击生成：不再立即返回 429，后端会打印“并发受限，退避重试 …”，前端最终要么拿到结果，要么在 60s 内得到明确的超时提示。

## 说明
- 此方案不依赖图床；仍使用 fallbackImage 作为示例图 URL（已实现）。
- 未来若要并发更高，可改为真正的队列与排队提示（SSE），本次 MVP 保持一次等待即拿结果。